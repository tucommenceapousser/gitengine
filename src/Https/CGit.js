/*
| Provides the http(s) interface for git repositories.
| Does both forwarding git requests as well provides a cgit web interface.
*/

def.abstract = true;

const cgi = require( 'cgi' );
const fs = require( 'fs/promises' );
const mimes = require( 'mime-types' );
const urlparse = require( 'url' ).parse;

const Https = tim.require( 'Https/Self' );
const Log = tim.require( 'Log/Self' );
const RepositoryManager = tim.require( 'Repository/Manager' );
const User = tim.require( 'User/Self' );

/*
| Directory where cgit config files are placed.
*/
let _confDir = './cgit/';

/*
| The path (in the URI) to serve cgit under.
*/
let _path;

/*
| Caches static data.
*/
const statics = { };

/*
| Set of users for which their cgit config file is uptodate.
*/
let generated = new Set( );

/*
| Invalides user or all cgit config files.
|
| ~username: the username to reset. true deletes everything.
*/
def.static.invalidate =
	async function( username )
{
	if( username === true )
	{
		generated = new Set( );
	}
	else
	{
		generated.delete( username );
	}
};

/*
| Sets the CGIT config directory.
*/
def.static.setConfDir =
	( dir ) => { _confDir = dir; };

/*
| Sets the CGIT path.
*/
def.static.setPath =
	( path ) => { _path = path; };

/*
| Serves a web view request.
| User is already authenticated.
|
| ~count: client counter
| ~req: request
| ~res: result
| ~urlSplit: url splitted into parts
| ~user: autenticated user
*/
def.static.serve =
	async function( count, req, res, urlSplit, user )
{
/**/if( CHECK )
/**/{
/**/	if( arguments.length !== 5 ) throw new Error( );
/**/	if( user.timtype !== User ) throw new Error( );
/**/}

	let url = req.url;
	if( url.charAt( 0 ) !== '/' )
	{
		return Https.error( res, '404', 'Not found' );
	}

	const username = user.username;
	if( !generated.has( username ) ) await Self._generateConf( user );

	// checks if it's a static file.
	url = url.substr( _path.length );
	const sfile = statics[ url ];
	if( sfile )
	{
		const header =
		{
			'content-type': sfile.mime,
			'cache-control': 'max-age=' + ( 60 * 60 ),
			'date': new Date().toUTCString()
		};
		res.writeHead( '200', header );
		return res.end( sfile.data );
	}

	// if not forwards it to cgit
	const env =
	{
		'CGIT_CONFIG': _confDir + username + '.conf',
	};

	// cuts away the virtual root
	req.url = req.url.substr( _path.length - 1 );
	if( req.url === '' ) req.url = '/';
	const uri = req.uri = urlparse( req.url );
	uri.href = decodeURI( uri.href );
	uri.path = decodeURIComponent( uri.path );
	uri.pathname = decodeURIComponent( uri.pathname );
	cgi( '/usr/lib/cgit/cgit.cgi', { env: env } )( req, res );
};

/*
| Starts the http(s) git server.
*/
def.static.start =
	async function( )
{
	Log.log( 'https-cgit', '*', 'caching cgit static files' );
	const path = '/usr/share/cgit/';
	const dir = await fs.readdir( path );
	for( let filename of dir )
	{
		const ext = filename.substr( filename.indexOf( '.' ) + 1 );
		const data = await fs.readFile( path + filename );
		const mime = mimes.lookup( ext );
		statics[ filename ] =
			Object.freeze( {
				data: data,
				mime: mime
		} );
	}
};

/*
| Generates the cgit config for one user.
|
| ~user:         user to write the config for
*/
def.static._generateConf =
	async function( user )
{
	const repositories = RepositoryManager.repositories( );
	const username = user.username;

	let text =
		'#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
		+ '# autogenerated by gitengine,\n'
		+ '# editing might proof futile.\n'
		+ '#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
		+ '\n'
		+ 'case-sensitive-sort=0\n'
		+ 'css=' + _path + 'cgit.css\n'
		+ 'enable-blame=1\n'
		+ 'enable-http-clone=0\n'
		+ 'local-time=1\n'
		+ 'logo=' + _path + 'cgit.png\n'
		+ 'max-repo-count=999999\n'
		+ 'enable-commit-graph=1\n'
		+ 'side-by-side-diffs=1\n'
		+ 'source-filter=/usr/lib/cgit/filters/syntax-highlighting.py\n'
		+ 'virtual-root=' + _path + '\n';

	for( let repo of repositories )
	{
		const perms = repo.getPermissions( user );
		if( !perms ) continue;
		text += '\nrepo.url=' + repo.name + '.git\n';
		text += 'repo.path=' + repo.path + '\n';
		if( repo.description ) text += 'repo.desc=' + repo.description + '\n';
		else text += 'repo.desc=\n';
		text += 'repo.owner=\n';
	}

	await fs.writeFile( _confDir + username + '.conf', text );
};
