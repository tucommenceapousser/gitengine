/*
| Provides the http(s) interface for git repositories.
| Does both forwarding git requests as well provides a cgit web interface.
*/

def.abstract = true;

const cgi = require( 'cgi' );
const fs = require( 'fs/promises' );
const mimes = require( 'mime-types' );
const urlparse = require( 'url' ).parse;

const Http = tim.require( 'GitEngine/Http/Self' );
const RepositoryManager = tim.require( 'GitEngine/Repository/Manager' );

const confDir = '/home/git/cgit/';

/*
| Caches static data.
*/
const statics = { };

/*
| Set of users for which their cgit config file is uptodate.
*/
let generated = new Set( );

/*
| Serves a web view request.
|
| User is already authenticated.
*/
def.static.serve =
	async function( req, res, user )
{
	let url = req.url;
	if( url.charAt( 0 ) !== '/' ) return Http.error( res, '404', 'Not found' );

	const username = user.username;
	if( !generated.has( username ) ) await Self._generateConf( user );

	// checks if it's a static file.
	url = url.substr( 1 );
	const sfile = statics[ url ];
	if( sfile )
	{
		const header =
		{
			'content-type': sfile.mime,
			'cache-control': 'max-age=' + ( 60 * 60 ),
			'date': new Date().toUTCString()
		};
		res.writeHead( '200', header );
		return res.end( sfile.data );
	}

	// if not forwards it to cgit
	const env =
	{
		'CGIT_CONFIG': confDir + username + '.conf',
	};
	const uri = req.uri = urlparse( req.url );
	uri.href = decodeURI( uri.href );
	uri.pat = decodeURIComponent( uri.path );
	uri.pathname = decodeURIComponent( uri.pathname );
	cgi( '/usr/lib/cgit/cgit.cgi', { env: env } )( req, res );
};

/*
| Invalides user or all cgit config files.
*/
def.static.invalidate =
	async function( username )
{
	if( username === true ) generated = new Set( );
	else generated.delete( username );
};

/*
| Starts the http(s) git server.
*/
def.static.start =
	async function( )
{
	console.log( '* caching cgit static files' );
	const path = '/usr/share/cgit/';
	const dir = await fs.readdir( path );
	for( let filename of dir )
	{
		const ext = filename.substr( filename.indexOf( '.' ) + 1 );
		const data = await fs.readFile( path + filename );
		const mime = mimes.lookup( ext );
		statics[ filename ] =
			Object.freeze( {
				data: data,
				mime: mime
		} );
	}
};

/*
| Generates the cgit config for one user.
|
| ~user:         user to write the config for
*/
def.static._generateConf =
	async function( user )
{
	const repositories = RepositoryManager.repositories( );
	const username = user.username;

	let text =
		'#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
		+ '# autogenerated by gitengine,\n'
		+ '# editing might proof futile.\n'
		+ '#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'
		+ '\n'
		+ 'case-sensitive-sort=0\n'
		+ 'enable-blame=1\n'
		+ 'enable-http-clone=0\n'
		+ 'local-time=1\n'
		+ 'max-repo-count=999999\n'
		+ 'side-by-side-diffs=1\n'
		+ 'source-filter=/usr/lib/cgit/filters/syntax-highlighting.py\n'
		+ 'virtual-root=\n';

	for( let repo of repositories )
	{
		const perms = repo.getPermissions( user );
		if( !perms ) continue;
		text += '\nrepo.url=' + repo.name + '.git\n';
		text += 'repo.path=' + repo.path + '\n';
		if( repo.description ) text += 'repo.desc=' + repo.description + '\n';
		else text += 'repo.desc=\n';
		text += 'repo.owner=\n';
	}

	await fs.writeFile( confDir + username + '.conf', text );

	/*
	text = '';
	for( let repo of repositories )
	{
		const perms = repo.getPermissions( user );
		if( !perms ) continue;
		text += repo.name + '.git\n';
	}
	await fs.writeFile( confDir + username + '.list', text );
	generated.add( username );
	*/
};
